{"version":3,"file":"content.bundle.js","mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://textpilot/./src/content.js"],"sourcesContent":["let ghostText = null;\r\nlet activeElement = null;\r\nlet isLoading = false;\r\n\r\n// Initialize observer for dynamic content\r\nconst observer = new MutationObserver((mutations) => {\r\n  mutations.forEach((mutation) => {\r\n    mutation.addedNodes.forEach((node) => {\r\n      if (node.nodeType === 1) { // Element node\r\n        attachToInputs(node);\r\n      }\r\n    });\r\n  });\r\n});\r\n\r\n// Attach to all text inputs\r\nfunction attachToInputs(root) {\r\n  const inputs = root.querySelectorAll('textarea, input[type=\"text\"], [contenteditable=\"true\"]');\r\n  inputs.forEach(input => {\r\n    input.addEventListener('focus', onFocus);\r\n    input.addEventListener('input', debounce(onInput, 300));\r\n  });\r\n}\r\n\r\n// Handle input focus\r\nfunction onFocus(e) {\r\n  activeElement = e.target;\r\n  updateSuggestion();\r\n}\r\n\r\n// Handle input changes\r\nasync function onInput(e) {\r\n  if (!e.target.matches('textarea, input[type=\"text\"], [contenteditable=\"true\"]')) return;\r\n  activeElement = e.target;\r\n  updateSuggestion();\r\n}\r\n\r\n// Initialize when DOM is ready\r\ndocument.addEventListener('DOMContentLoaded', () => {\r\n  // Start observing dynamic content changes\r\n  observer.observe(document.body, {\r\n    childList: true,\r\n    subtree: true\r\n  });\r\n  \r\n  // Attach to existing inputs\r\n  attachToInputs(document);\r\n});\r\n// Keyboard shortcuts\r\nconst KEYS = {\r\n  ACCEPT: ['Tab', 'ArrowRight'],\r\n  REJECT: ['Escape'],\r\n  NEXT: ['Alt+]'],\r\n  PREV: ['Alt+[']\r\n};\r\n\r\ndocument.addEventListener('keyup', debounce(async (e) => {\r\n  if (!e.target.matches('textarea, input[type=\"text\"], [contenteditable=\"true\"]')) return;\r\n  \r\n  activeElement = e.target;\r\n  updateSuggestion();\r\n}, 300));\r\n\r\ndocument.addEventListener('keydown', (e) => {\r\n  if (!ghostText?.element) return;\r\n\r\n  if (KEYS.ACCEPT.includes(e.key)) {\r\n    e.preventDefault();\r\n    acceptSuggestion();\r\n  } else if (KEYS.REJECT.includes(e.key)) {\r\n    e.preventDefault();\r\n    rejectSuggestion();\r\n  }\r\n});\r\n\r\n// Update your updateSuggestion function\r\nasync function updateSuggestion() {\r\n  if (!activeElement || isLoading) return;\r\n\r\n  const cursorPosition = activeElement.selectionStart;\r\n  const text = activeElement.value || activeElement.textContent;\r\n  const precedingText = text.substring(0, cursorPosition);\r\n  \r\n  // Only suggest if we have enough context\r\n  if (precedingText.trim().length < 2) {\r\n    ghostText?.element?.remove();\r\n    return;\r\n  }\r\n\r\n  try {\r\n    isLoading = true;\r\n    showLoadingIndicator();\r\n    \r\n    const suggestion = await getSuggestion(precedingText);\r\n    if (suggestion && activeElement.selectionStart === cursorPosition) {\r\n      showGhostText(activeElement, suggestion, cursorPosition);\r\n    }\r\n  } catch (error) {\r\n    console.error('TextPilot suggestion error:', error);\r\n  } finally {\r\n    isLoading = false;\r\n    hideLoadingIndicator();\r\n  }\r\n}\r\n\r\nfunction showGhostText(element, suggestion, cursorPosition) {\r\n  const ghostElement = document.createElement('div');\r\n  ghostElement.className = 'textpilot-ghost-text';\r\n  \r\n  const rect = element.getBoundingClientRect();\r\n  const computedStyle = window.getComputedStyle(element);\r\n  const lineHeight = parseInt(computedStyle.lineHeight);\r\n  \r\n  // Calculate position based on cursor\r\n  const textBeforeCursor = element.value.substring(0, cursorPosition);\r\n  const lines = textBeforeCursor.split('\\n').length;\r\n  \r\n  ghostElement.style.top = `${rect.top + (lines - 1) * lineHeight}px`;\r\n  ghostElement.style.left = `${rect.left}px`;\r\n  ghostElement.style.font = computedStyle.font;\r\n  ghostElement.textContent = suggestion;\r\n  \r\n  ghostText = {\r\n    element: ghostElement,\r\n    suggestion: suggestion\r\n  };\r\n  \r\n  document.body.appendChild(ghostElement);\r\n\r\n  // Add visual cues for keyboard shortcuts\r\n  const shortcuts = document.createElement('div');\r\n  shortcuts.className = 'textpilot-shortcuts';\r\n  shortcuts.textContent = 'â‡¥ to accept';\r\n  ghostElement.appendChild(shortcuts);\r\n}\r\n\r\nfunction acceptSuggestion() {\r\n  if (!ghostText?.element || !activeElement) return;\r\n  \r\n  const cursorPosition = activeElement.selectionStart;\r\n  const originalText = activeElement.value;\r\n  \r\n  activeElement.value = originalText.substring(0, cursorPosition) +\r\n                       ghostText.suggestion +\r\n                       originalText.substring(cursorPosition);\r\n  \r\n  ghostText.element.remove();\r\n  ghostText = null;\r\n}\r\n\r\nasync function getSuggestion(text) {\r\n  const response = await new Promise((resolve, reject) => {\r\n    chrome.runtime.sendMessage({ action: 'getSuggestion', text }, (response) => {\r\n      if (chrome.runtime.lastError) {\r\n        reject(new Error(chrome.runtime.lastError.message));\r\n      } else if (response.error) {\r\n        reject(new Error(response.error));\r\n      } else {\r\n        resolve(response);\r\n      }\r\n    });\r\n  });\r\n  return response.suggestion;\r\n}\r\n\r\n// Helper functions\r\nfunction debounce(func, wait) {\r\n  let timeout;\r\n  return function executedFunction(...args) {\r\n    clearTimeout(timeout);\r\n    timeout = setTimeout(() => func.apply(this, args), wait);\r\n  };\r\n}\r\n\r\nfunction showLoadingIndicator() {\r\n  const loader = document.createElement('div');\r\n  loader.className = 'textpilot-loading';\r\n  document.body.appendChild(loader);\r\n}\r\n\r\nfunction hideLoadingIndicator() {\r\n  const loader = document.querySelector('.textpilot-loading');\r\n  if (loader) loader.remove();\r\n}\r\n\r\n"],"names":[],"sourceRoot":""}